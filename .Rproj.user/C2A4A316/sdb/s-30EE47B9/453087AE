{
    "collab_server" : "",
    "contents" : "---\ntitle: \"cuttinz\"\noutput: pdf_document\n---\n\n*****\n\n## Working with dates\n\nBecause the need to use dates is so common, let's look in a little detail how to process them so that we they can be used in analysis and visualisation.\n\nOur dataframe has a date field **but it's only in the form of a text string at the moment. We want R to understand it as a formatted date.** You can check what type each variable is by using R's **class** function. So the current date column is:\n\n```{r}\nclass(luton$date)\n\n#Oh! \nluton$year <- year(luton$date)\n\n```\n\n\n```{r eval=F}\n\nluton$date_formatted <- \n  as.Date(luton$date, format = '%Y-%m-%d')\n\nluton$year <- year(luton$date_formatted)\n\n```\n\nWhat's going on with *as.Date*? If you look at the format of the date in your land registry data, you'll see it's e.g. **'2003-09-19'**. So it's format is: **'year-month-day'**. The as.Date function tells R this is text that's in this date format, so it can convert to something it understands as a date. If we were using the more common English date format of **'day-month-year'**, you'd tell R this with **format = '%d-%m-%Y'**.\n\nJust a couple of other date-formatting things to note. \n\n* First: if the date was **'2003/09/19'** (i.e. the numbers are separated by **slashes** instead of **dashes**) you'd just tell R the separators are slashes, like this: **format = '%d/%m/%Y'**. \n* Second: the year marker is a capital to indicate the full year is used - **'2003'**, not **'03'**. If the date used the shorter year version, you'd just use a lower-case **y**.\n\n\n#Factor bits\n\nHowever: it's not really clear what **reorder** did with the avPrice to set the levels. What we really want is to **order by the average price over all years** (that we used previously to get our subset of ten wards).\n\nThere are various ways of doing this, but a useful one is to **add a new column with these average prices per ward to the dataframe** so we can then use **reorder** in the same way.\n\nTo do this, we need to introduce another **dplyr verb: `mutate'.** This is the cousin of **summarise** that we used before. The difference being: **it can be used to add a new column to an existing dataframe**. This is **mutating** the original dataframe, rather than **summarising** to a new one.\n\nThis will make more sense if it's seen in action. We group by ward, as before. **Try this and then take a look at data4viz in its own tab:**\n\n```{r}\ndata4viz <- data4viz %>% \n  group_by(ward) %>% \n  mutate(avPerWardOverAllYears = mean(avPrice))\n```\n\nIf you scroll through the data, it has a **new column containing the average of prices for all years in that ward**. It's the same value for each ward - **this would have been our single observation if we'd used summarise**. So they are doing the same thing - **but putting the results in different places.**\n\n**The ward variable can now be reordered using these overall averages:**\n\n```{r}\n#Reorder ward with our new mutated column\ndata4viz$ward <- \n  reorder(data4viz$ward, -data4viz$avPerWardOverAllYears)\n\n#Check the new levels\nlevels(data4viz$ward)\n```\n\n\n\n\n\n\n#\n\nSo **R took each of the ten unique ward names in our top/bottom ward list and assigned them a level**. By default, R assigns levels in **alphabetical order**.\n\n\n#\n\n\n## Changing colour\n\nSo let's try and pick some better colours to make it easier to distinguish which ward is which.\n\n\n```{r echo = F,fig.width=6.2, fig.height=3.5}\nggplot() +\n  geom_line(data = data4viz, aes(x = year, y = avPrice, colour = ward)) +\n  scale_y_log10() +\n  scale_color_brewer(palette = 'Set3')\n\n```\n\n#\n\nAs long as the data can fit onto the same canvas, **we can even add different dataframes to the plot.** This would allow us to do the following:\n\n```{r}\ndata4viz_topWards <- data4viz %>% \n  filter(ward %in% topBottomWards[1:5]) %>% \n  rename(topwards = ward)\n\ndata4viz_bottomWards <- data4viz %>% \n  filter(ward %in% topBottomWards[6:10]) %>% \n  rename(bottomwards = ward)\n\n\ndata4viz_bottomWards$bottomwards <- as.character(data4viz_bottomWards$bottomwards)\ndata4viz_topWards$topwards <- as.character(data4viz_topWards$topwards)\n```\n\n```{r eval = F}\noutput <- ggplot() +\n  geom_point(data = data4viz, \n             aes(x = year, y = avPrice, size = countOfSales), \n             colour = 'grey') +\n  geom_line(data = data4viz_topWards , aes(x = year, y = avPrice, colour = topwards)) +\n  geom_line(data = data4viz_bottomWards, aes(x = year, y = avPrice, colour = bottomwards)) +\n  scale_y_log10()\n\noutput\n```\n\n\n*****\n\n# Extra bits\n\n## Subsetting data with dplyr\n\nAs we did above, here's another way to get the **top and bottom five wards**, measured by their average price over all years, but just using **dplyr**.\n\n\n```{r echo = F, eval = F}\n#Just for me to re-run\naveragePricePerWard <- luton_w_geogs %>% \n  group_by(ward,year) %>% \n#  summarise(avPrice = mean(price), count = n())\n  summarise(avPrice = mean(price))\n  \n```\n\nTo do this, we need to introduce another **dplyr verb: `mutate'.** This is the cousin of **summarise** that we used before. The difference being: **it can be used to add a new column to an existing dataframe**. This will make more sense if it's seen in action. Recall, our current *averagePricePerWard* dataframe that we got from **summarise** looks like this:\n\n```{r fig.width=3.8, fig.height=2, echo=FALSE}\nimg <- readPNG(\"images/avPriceAgain.png\")\n grid.raster(img)\n```\n\nLet's take this dataframe and group it by ward again. And then we'll use **mutate** thus:\n\n```{r}\naveragePricePerWard <- averagePricePerWard %>%\n  group_by(ward) %>% \n  mutate(avPerWard = mean(avPrice))\n```\n\nLooking again at its tab, we have that new column, **avPerWard**, but **unlike with summarise, the average has been added to the original dataframe**, repeated for each observation in the wards we grouped (scroll through the data to see it does in fact have a different average price per ward).\n\n```{r fig.width=3.8, fig.height=2, echo=FALSE}\nimg <- readPNG(\"images/av_mutate.png\")\n grid.raster(img)\n```\n\nNow we can add **another column ranking these averages**, so that we can then use those ranks to select the top and bottom wards we want.\n\n```{r}\naveragePricePerWard <- averagePricePerWard %>% \n  ungroup() %>% \n  mutate(rankPrice = dense_rank(avPerWard))\n```\n\nA couple of points here. First, **we had to ungroup it, as the grouping was still in effect from the previous code.** If it remains grouped, we just get *the rank in each ward*, which we don't want. Second, **dense_rank** gives us **one rank value for all values that are equal.** So we get a rank value for each ward's average.\n\nJust to prove that worked:\n\n```{r}\n#What's range of the ranking we just worked out?\nrange(averagePricePerWard$rankPrice)\n\n#Get all unique ward names. How many are there?\nunique(averagePricePerWard$ward) %>% length\n\n```\n\nNow all that's left to do is use those rank values to get a **subset of the wards**. We do this with dplyr's **filter verb**. If, for example, we wanted to just keep the **bottom five wards**, we could do this:\n\n```{r}\nsubsetOfAvPropPrices <- averagePricePerWard %>% \n  filter(rankPrice < 6)\n```\n\nTo keep **both** the bottom **and** top values is slightly more fiddly, but not too much:\n\n```{r}\nsubsetOfAvPropPrices <- averagePricePerWard %>% \n  filter(rankPrice < 6 | rankPrice > 99)\n```\n\nA couple of new things going on there. Firstly: \n\n* **The vertical bar**: this is one of R's [logical operators](http://www.statmethods.net/management/operators.html). It means 'OR'. So filter is saying: 'give us values that have a rank below 6 **or** above 99'.\n\nNote also: we know from above there are 104 wards in total, so can deduce the top five are between 100-104. But we could also find the top five **by finding the maximum rank value**:\n\n```{r}\nsubsetOfAvPropPrices <- averagePricePerWard %>% \n  filter(rankPrice < 6 | rankPrice > max(averagePricePerWard$rankPrice)-5)\n\n#Proving that gets us the same value\nmax(averagePricePerWard$rankPrice)-5\n```\n\n\n\n\n\n\n\n```{r}\nlondonChange <- findChangePerYearForTopAndBottomWards(london)\n```\n\n\n\n\n```{r}\nfindChangePerYearForTopAndBottomWards <- function(cityF){\n\n  pricePerWard <- cityF %>% \n    group_by(ward) %>% \n    summarise(avPrice = mean(price), count = n()) %>% \n    arrange(-avPrice)\n  \n  #drop wards with small observation numbers\n  \n  #Keep only changes in the top ten and bottom ten wards. 798\n  nrow(pricePerWard)\n  \n  #topBottomWards <- pricePerWard$ward[c(1:10,789:798)]\n  # topBottomWards <- pricePerWard$ward[c(1:(nrow(pricePerWard)/2),\n  #   (nrow(pricePerWard/2)+1):nrow(pricePerWard))]\n  \n  #Keep em all, split average.\n  #1 is top half, 2 is bottom half\n  topBottomWards <- pricePerWard %>% \n    mutate(topBottom = cut_number(-avPrice,2) %>% as.numeric())\n  \n  #prove that worked\n  table(topBottomWards$topBottom)\n  \n  #Add the top/bottom label to the original data\n  #Marking which wards have highest/lowest overall price\n  london <- full_join(london, \n                       topBottomWards %>% select(ward, topBottom),\n                       by = 'ward')\n  \n  #Reasonably even split of sales number\n  table(london$topBottom)\n  \n  #Now we can summarise average price per group\n  #Quite a small dataset as we're just getting average price per year\n  #For TWO groups\n  pricePerWardGroupPerYear <- city %>% \n    group_by(topBottom,year) %>% \n    summarise(avPrice = mean(price), countOfSales = n())\n  \n  #Relies on correct order of years in the result above. Which we have.\n  CHANGEPerGroupPerYear <- pricePerWardGroupPerYear %>% \n    group_by(topBottom) %>% \n    mutate(totalChange = avPrice - lag(avPrice)) %>% \n    mutate(percentChange = ((avPrice - lag(avPrice))/lag(avPrice))*100)\n  \n  #Don't need the NAs\n  CHANGEPerGroupPerYear <- CHANGEPerGroupPerYear %>% \n    filter(!is.na(totalChange))\n  \n  return(CHANGEPerGroupPerYear)\n\n}\n\n```\n\n\n\n\nlondon_pricePerWard <- london %>% \n  group_by(ward) %>% \n  summarise(avPrice = mean(price), count = n()) %>% \n  arrange(-avPrice)\n\n#Keep only changes in the top ten and bottom ten wards. 798\nnrow(london_pricePerWard)\n\n#Keep em all, split average.\n#1 is top half, 2 is bottom half\nlondon_topBottomWards <- london_pricePerWard %>% \n  mutate(topBottom = cut_number(-avPrice,2) %>% as.numeric())\n\n#prove that worked\ntable(london_topBottomWards$topBottom)\n\n#Add the top/bottom label to the original data\n#Marking which wards have highest/lowest overall price\nlondon <- full_join(london, \n                     london_topBottomWards %>% select(ward, topBottom),\n                     by = 'ward')\n\n#Reasonably even split of sales number\ntable(london$topBottom)\n\n#Now we can summarise average price per group\n#Quite a small dataset as we're just getting average price per year\n#For TWO groups\nlondon_pricePerWardGroupPerYear <- london %>% \n  group_by(topBottom,year) %>% \n  summarise(avPrice = mean(price), countOfSales = n())\n\n\n\n\n```{r echo = F}\n#save and reload both of those bar change dfs\n#saveRDS(luton_CHANGEPerGroupPerYear,'data/lutonChange.rds')\n#saveRDS(london_CHANGEPerGroupPerYear,'data/londonChange.rds')\n\n#Shifted over to markdown folder. Still not sure why it doesn't reference parent proj folder.\nluton_CHANGEPerGroupPerYear <- readRDS('data/lutonChange.rds')\n```\n\n\n\n\n\n\n\n```{r eval = F}\nluton_pricePerWard <- luton_w_geogs %>% \n  group_by(ward) %>% \n  summarise(avPrice = mean(price), count = n()) %>% \n  arrange(-avPrice)\n\n#Keep only changes in the top ten and bottom ten wards. 798\nnrow(luton_pricePerWard)\n\n#Keep em all, split average.\n#1 is top half, 2 is bottom half\nluton_topBottomWards <- luton_pricePerWard %>% \n  mutate(topBottom = cut_number(-avPrice,2) %>% as.numeric())\n\n#prove that worked\ntable(luton_topBottomWards$topBottom)\n\n#Add the top/bottom label to the original data\n#Marking which wards have highest/lowest overall price\nluton_w_geogs <- full_join(luton_w_geogs, \n                     luton_topBottomWards %>% select(ward, topBottom),\n                     by = 'ward')\n\n#Reasonably even split of sales number\ntable(luton_w_geogs$topBottom)\n\n#Now we can summarise average price per group\n#Quite a small dataset as we're just getting average price per year\n#For TWO groups\nluton_pricePerWardGroupPerYear <- luton_w_geogs %>% \n  group_by(topBottom,year) %>% \n  summarise(avPrice = mean(price), countOfSales = n())\n\n#Relies on correct order of years in the result above. Which we have.\nluton_CHANGEPerGroupPerYear <- luton_pricePerWardGroupPerYear %>% \n  group_by(topBottom) %>% \n  mutate(totalChange = avPrice - lag(avPrice)) %>% \n  mutate(percentChange = ((avPrice - lag(avPrice))/lag(avPrice))*100)\n\n#Don't need the NAs\nluton_CHANGEPerGroupPerYear <- luton_CHANGEPerGroupPerYear %>% \n  filter(!is.na(totalChange))\n```\n\n\n\n\nlondon_pricePerWardGroupPerYear$ttwa_name <- 'london'\n\nluton_pricePerWardGroupPerYear$ttwa_name <- 'luton'\n\nboth <- rbind(london_pricePerWardGroupPerYear,luton_pricePerWardGroupPerYear) %>% \n  select(-countOfSales)\n\nboth2 <- both %>% \n  spread(ttwa_name,avPrice)\n\n#Or don't bother with all that and just graph the prices",
    "created" : 1479722726142.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3159648714",
    "id" : "453087AE",
    "lastKnownWriteTime" : 1479757140,
    "last_content_update" : 1479757140884,
    "path" : "C:/Users/SMI2/Dropbox/SheffieldMethodsInstitute/Training/Intro_to_R_Nov2016/Introduction2Wrangling_n_Viz_R/RMarkdown/cuttinz.Rmd",
    "project_path" : "RMarkdown/cuttinz.Rmd",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}